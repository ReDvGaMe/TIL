# 알고리즘

코딩 테스트 통과 및 컴퓨팅 사고능력을 기르기 위해 학습

---

## 목차
1. [개요](#1.-개요))
2. 문제 해결 시작하기
3. 알고리즘 분석
    - 시간 복잡도 분석
    - 정당성 증명
4. 알고리즘 설계 패러다임
    - 무식하게 풀기
    - 분할 정복
    - 동적 계획법
    - 탐욕법
5. 유명한 알고리즘들
    - 정수론
6. 기초 자료 구조
    - 비트마스트
    - 부분 합
    - 선형 자료 구조
    - 큐, 스택, 데크
7. [트리](#7.-트리)
    - 트리의 구현과 순회
    - 이진 검색 트리
    - 우선순위 큐와 힙
    - 구간 트리
    - 산호 배타적 집합
8. [그래프](#8.-그래프)
    - 그래프의 표현과 정의
    - DFS
    - BFS
    - 최단 경로 알고리즘
    - 최소 스패닝 틜
    - 네트워크 유량

---

---
## 1. 개요
---
### 알고리즘을 잘하기 위한 3요소
1. 구현력
    내가 생각한 알고리즘을 그대로 소스코드로 구현하는 과정  
    구현력 부족 시 대충 어떻게 하라는지는 알지만 코딩은 막힘  
    → 내가 어떤 프로그램을 만들고자 하는지를 명확히!  
    → 무엇을 입력받아 어디에 저장하고 어떤 과정을 거쳐 중간결과와 최종 결과물은 어떤 것인지 파악    
    순서도 그리는 연습!
2. 문제해결능력  
    문제해결능력 부족시 어떻게 접근해야 할지 모름   
    → 양질의 문제를(30~2시간 이내에 고민 및 해결 가능한 문제)를 풀고 이미 풀어본 문제들을 정리  
3. 배경지식 
    기초적인 수학지식을 의미    
    코딩 문법, 시,공간 복잡도 분석, 자료구조(배열, 트리, 그래프, 힙, BST, 스택, 큐), 기초 알고리즘(DFS, BFS, 정렬, 백트래킹, DP, 분할정복, 최단거리)    
    배경지식을 충분히 공부했음에도 문제 접근이 힘들면 컴퓨팅적 사고력이 부족한 것   

---
## 7. 트리
---
### 1. 트리의 구현과 순회
#### 트리
계층적 구조를 갖는 자료들을 표현하기 위한 자료 구조  
현실 세계의 개념을 추상화해 표현하는 자료 구조로 고안되었지만, 탐색형 자료 구조로도 유용하게 쓰임(작업 속도가 빠름)  

#### 트리의 표현
```
struct TreeNode {
    string label;   // 저장할 자료(문자열은 예시)
    TreeNode* parent;   // 부모 노드를 가리키는 포인터
    vector<TreeNode*> chilren;  // 자손 노드들을 가리키는 포인터의 배열
}
```
이 객체 *TreeNode*는 특정 구조나 형태를 가정하지 않음  
즉, 어떤 형태의 트리라도 트리의 가장 기초적인 조건을 충족하기만 한다면 표현할 수 있다는 뜻

#### 트리의 순회
트리는 구조가 일정하지 않기 때문에 포함된 모든 자료들을 순회하기가 어려움  
이와 같은 일을 쉽게 하기 위해서는 **트리의 재귀적 속성**을 이용해야함  
모든 트리는 각 자식들을 루트로 하는 서브트리와 루트로 나눌 수 있으므로, 트리의 루트가 주어질 때 루트를 방문한 뒤 각 서브트리를 재귀적으로 방문하는 함수를 만들어 트리의 모든 노드를 순회할 수 있음
```
// 주어진 트리의 각 노드에 저장된 값을 모두 출력
void printLabels(TreeNode* root){
    // 루트에 저장된 값을 출력
    cout << root->label << endl;
    // 각 자손들을 루트로 하는 서브트리에 포함된 값들을 재귀적으로 호출
    for(int i = 0; i < root->children.size(); i++)
        printLables(root->children[i]);
}
```

트리의 순회에는 O(n)의 시간이 들음

### 2. 이진 검색 트리
**검색 트리**는 연결 리스트나 큐처럼 자료들을 담는 컨테이너지만, 자료들을 일정한 순서에 따라 **정렬한 상태**로 저장해 둠  

이진 검색 트리에서는 각 노드의 왼쪽 서브트리에는 해당 노드의 원소보다 작은 원소를 가진 노드들이, 오른쪽에는 큰 원소를 가진 노드들이 들어감  
이진 검색 트리를 중위 순회하면 크기 순서로 정렬된 원소의 목록을 얻을 수 있음  
이진 검색 트리는 집합에 원소를 추가하거나 삭제하는 **조작 연산**을 할 때 강력함

#### 트립
> 구현이 간단한 균형잡힌 이진 검색 트리  

입력이 특정 순서로 주어질 때 성능이 떨어진다는 이진 검색 트리의 단점을 해결하기 위해 고안된 일종의 **랜덤화된 이진 검색 트리**  
트립은 이진 검색 트리와 같은 성질을 가지고 있지만 트리의 형태가 원소들의 추가 순서에 따라 결정되지 않고 난수에 의해 임의대로 결정됨  
때문에 원소들이 어느 순서대로 추가되고 삭제되더라도 **트리 높이의 기대치**는 **항상 일정**  
이와 같은 속성을 유지하기 위해 트립은 새 노드가 추가될 때마다 해당 노드에 우선순위를 부여 *(이 우선순위는 난수를 통해 생성)*  
트립은 항상 부모의 우선 순위가 자식의 우선순위보다 높은 이진 검색 트리를 만듬 *(힙과도 같은 성질, 힙(heap)과 트리(tree)의 성질을 모두 가지고 있어서 트립(treap))*  
그렇기 때문에 트립의 조건은 다음 두 가지로 정리 가능
 - 이전 검색 트리의 조건 : 모든 노드에 대해 왼쪽 서브트리에 있는 노드들의 원소는 해당 노드의 원소보다 작고, 오른쪽 서브트리에 있는 노드들의 원소는 해당 노드의 원소보다 큼
 - 힙의 조건 : 모든 노드의 우선순위는 각자의 자식 노드보다 크거나 같음

```
typedef int KeyType;
// 트립의 한 노드를 저장
struct Node{
    // 노드에 저장된 원소
    KeyType Key;
    // priority : 이 노드의 우선순위
    // size : 이 노드를 루트로 하는 서브트리의 크기
    int priority, size;
    // 두 자식 노드의 포인터
    Node *left, *right;
    // 생성자에서 난수 우선순위를 생성하고, size와 left / right를 초기화
    Node(const KeyType& _Key) : key(_key), priority(rand()), size(1), left(NULL), right(NULL) {}
    void SetLeft(Node* newLeft) { left = newLeft; calcSize(); }
    void SetRight(Node* newRight) { right = newRight; calcSize(); }
    // size 멤버를 갱신
    void calcSize(){
        size = 1;
        if(left) size += left->size;
        if(right) size += right->size;
    }
}
```

k번째 원소 찾기
이진 검색 트리를 직접 작성하는 것은 표준 라이브러리의 구현에서 제공하지 않는 기능이 필요할 때  
그 중 하나가 주어진 서브트리의 노드들을 포함한 원소의 크기 순으로 나열했을 때 k번째로 오는 노드를 찾는 연산  
Node 클래스는 서브트리의 크기 size를 계산해 저장해 두기 때문에 이것을 구현하기 어렵지 않음
 - k <= l : k번째 노드는 왼쪽 서브트리에 속해 있음
 - k = l+1 : 루트가 k번재 노드
 - k > l+1 : k번째 노드는 오른쪽 서브트리에서 k - l - 1번째 노드가 됨

 ```
 // root를 루트로 하는 트리 중에서 k번째 원소를 반환
 Node* kth(Node* root, int k){
     // 왼쪽 서브트리의 크기를 우선 계산
     int leftSize = 0;
     if(root->left != NULL) leftSize = root->left->size;
     if(k <= leftSize) return kth(root->left, k);
     if(k == leftSize + 1) return root;
     return kth(root->right, k - leftSize - 1);
 }
 ```

### 3. 우선순위 큐와 힙
#### 우선순위 큐
큐와 유사하나 가장 먼저 입력된 자료가 가장 먼저 꺼내지는 것이 아닌,   
**우선순위**가 가장 높은 자료가 가장 먼저 꺼내지는 큐  
균현 잡힌 이진 검색 트리를 사용하면 원소를 찾아 삭제하는 일과 새 원소를 삽입하는 일을 모두 O(logN) 시간에 할 수 있으나, 이는 단순한 작업에 어울리지 않음  
따라서 더욱 단순한 구조로 우선순위 큐를 구현할 필요가 있음

#### 힙
이에 적합한 것이 **힙(heap)**  
힙은 가장 큰 원소를 찾는 것에 최적화된 형태의 이진 트리  
새 원소를 추가하는 연산과 가장 큰 원소를 꺼내는 연산을 모두 O(logN) 시간에 수행 가능  
대부분의 프로그래밍 언어의 표준 라이브러리에 포함되어 있기 때문에 직접 구현할 일이 거의 없음

힙이 갖는 가장 중요한 규칙은 부모 노드가 가진 원소는 항상 자식 노드가 가진 원소 이상이라는 것, 이를 **힙의 대소 관계 규칙**이라고 부름  
힙에서 대소 관계 규칙은 부모 자식 관계에만 적용되며, 왼쪽 자식과 오른쪽 자식이 갖는 원소의 크기는 제한하지 않음  

트리가 한쪽으로 기울어지는 일을 막기 위해서 힙 또한 트리의 구조에 제한을 둠
 - 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차있어야 함
 - 마지막 레벨에 노드가 있을 때는 항상 가장 왼쪽부터 순서대로 채워져 있어야 함  

이러한 엄격한 모양 규칙은 구현할 때 장점으로 작용함  
 - A[i]에 대응되는 노드의 왼쪽 자손은 A[2 x i + 1]에 대응됨
 - A[i]에 대응되는 노드의 오른쪽 자손은 A[2 x i + 2]에 대응됨
 - A[i]에 대응되는 노드의 부모는 A[(i - 1) / 2]에 대응됨(나눗셈 결과는 내림)
 
힙의 모양 규칙에 의해 힙에 n개의 노드가 있을 때 이 노드들은 A[0]에서 A[n-1]까지 순차적으로 대응함

#### 새 원소의 삽입
힙의 모든 조건을 유지하면서 새 원소를 삽입 할 때 여러 번거로움을 피할 수 있는 방법은 대소 관계 규칙 대신 모양 규칙을 먼저 만족시키는 것  
모양 규칙에 의해 새 노드는 항상 heap[]의 맨 끝에 추가한 후 힙의 대소 관계 속성을 만족시키기는 간단함  
마지막에 추가한 새 원소를 자신의 부모 노드가 가진 원소와 비교하고, 부모 노드가 가진 원소가 작다면 두 원소의 위치를 바꿈. 새 원소가 더 크거나 같은 원소를 가진 부모 노드를 만나거나 루트에 도달할 때까지 반복
```
// 정수를 담는 최대 힙 heap에 새 원소 newValue를 삽입 
void push_heap(vector<int>& heap, int newValue){
    // 힙의 맨 끝에 newValue를 추가
    heap.push_back(newValue)
    // 현재 newValue의 위치
    int idx = heap.size() - 1;
    // 루트에 도달하거나 newValue 이상의 원소를 가진 조상을 만날 때까지
    while(idx > 0 && heap[(idx - 1) / 2] < heap[idx]){
        swap(heap[idx], heap[(idx - 1) / 2]);
        idx = (idx - 1) / 2;
    }
}
```

#### 최대 원소 꺼내기
배열을 이용해 구현한 최대 힙에서 최대 원소는 배열의 첫 원소를 확인하면 됨  
문제는 최대 원소를 힙에서 꺼내는 일, 힙의 엄격한 모양 제한 때문에 구현이 까다로움  
새 원소의 삽입과 같이 모양 규칙을 충족하는 힙을 먼저 만든 뒤 대소 관계 규칙을 만족하도록 조작하면 좀 더 간단하게 구현 가능  
힙의 모양 구조에 의해 힙의 마지막에 있는 노드는 어차피 지워질 것임, 따라서 이 노드를 일단 지우고 시작함  
*(이 노드는 리프이기 때문에 노드가 지워져도 힙의 구조에는 영향을 끼치지 않음)*  
마지막 노드에 있던 원소를 루트에 덮어 씌우면 힙의 모양 규칙은 만족시킴  

이후에 힙의 대소 관계 조건을 만족시키기 위해 루트가 두 자식이 가지고 있던 원소 중 큰 쪽이 루트에 올라와야하기 때문에, 두 자식 노드가 가진 원소 중 큰 원소와 맞바꿈  
그리고 이 작업을 트리의 바닥에 도달하거나, 두 자손이 모두 자기 자신 이하의 원소를 갖고 있을 때까지 반복하면 됨
```
// 정수를 담는 최대 힙 heap에서 heap[0]을 제거
void pop_heap(vector<int>& heap){
    // 힙의 맨 끝에서 값을 가져와 루트에 덮어씌움
    heap[0] = heap.back();
    heap.pop_back();
    int here = 0;
    while(true){
        int left = here * 2 + 1, right = here * 2 + 2;
        // 리프에 도달한 경우
        if(left >= heap.size()) break;
        // heap[here]가 내려갈 위치를 찾음
        int next = here;
        if(heap[next] < heap[left])
            next = left;
        if(right < heap.size() && heap[next] < heap[right])
            next = right;
        if(next == here) break;
        swap(heap[here], heap[next]);
        here = next;
    }
}
```

### 4. 구간 트리
구간 트리는 흔이 일차원 배열의 특정 구간에 대한 질문을 빠르게 대답하는데 사용함  
구간 최소 쿼리(range minimum query, RMQ)라고 불리는 특정 구간의 최소치를 찾는 문제는 구간 트리의 예 중 하나  
```
(0, 14)
(0, 7)                                        | (8, 14)
(0, 3)                | (4, 7)                | (8, 11)                 | (12, 14)
(0, 1)    | (2, 3)    | (4, 5)    | (6, 7)    | (8, 9)    | (10, 11)    | (12, 13)    | (14)
(0) | (1) | (2) | (3) | (4) | (5) | (6) | (7) | (8) | (9) | (10) | (11) | (12) | (13) | (14)
```
↑ 길이 15인 배열을 표현하는 구간 트리가 저장하는 구간들  

#### 구간 트리의 표현
구간 트리는 비교적 **'꽉 찬' 이진 트리**임  
꽉 찬 이진 트리는 포인터로 연결된 객체를 표현하기보다는 **배열로 표현하는 것**이 메모리를 더 절약할 수 있음  
루트 노드를 배열의 1번 원소로, 노드 i의 왼쪽 자손과 오른쪽 자손을 각각 2 x i와 2 x i + 1번 원소로 표현  
이 배열의 길이는 가장 가까운 2의 거듭제곱으로 n을 올림한 뒤 2를 곱하거나 그냥 n에 4를 곱해도 됨(메모리는 손해)

#### 구간 트리의 초기화
```
// 배열의 구간 최소 쿼리를 해결하기 위한 구간 트리의 구현
struct RMQ{
    // 배열의 길이
    int n;
    // 각 구간의 최소치
    vector<int> rangeMin;
    RMQ(const vector<int>& array){
        n = array.size();
        rangeMin.resize(n * 4);
        init(array, 0, n-1, 1);
    }
}
// node 노드가 array[left..right] 배열을 표현할 때
// node를 루트로 하는 서브트리를 초기화하고, 이 구간의 최소치를 반환
int init(const vector<int>& array, int left, int right, int node){
    if(left == right)
        return rangeMin[node] = array[left];
    int mid = (left + right) / 2;
    int leftMin = init(array, left, mid, node * 2);
    int rightMin = init(array, mid + 1, right, node * 2 + 1);
    return rangeMin[node] = min(leftMin, rightMin);
}
```
위의 코드는 RMQ 문제를 해결하는 RMQ 클래스의 구조와 각 노드마다 해당 구간의 최소치를 계산하는 함수 init()을 구현한 것  
구간 트리의 각 노드에 대해 위치 등을 저장해 두지 않음  
(해당 노드를 찾아가는 과정에서 표현하는 구간을 동적으로 계산할 수 있기 때문에 저장하지 않아도 됨)  

#### 구간 트리의 질의 처리
초기화를 했으면 임의의 구간의 최소치를 구할 준비가 된 것  
이것을 구간 트리에서의 질의(query) 연산 이라고 부름  
질의 연산은 구간 트리에서의 순회를 응용해 간단하게 구현 가능  

    query(left, right, node, nodeLeft, nodeRight) = node가 표현하는 범위 [nodeLeft, nodeRight]와 우리가 최소치를 찾기 원하는 구간 [left, right]의 교집합의 최소 원소를 반환

- 교집합이 공집합인 경우  
    두 구간은 서로 겹치지 않음, 따라서 반환 값음 존재하지 않음.  
    반환 값이 무시되도록 아주 큰 값을 반환
- 교집합이 [nodeLeft, nodeRight]인 경우  
    [left, right]가 노드가 표현하는 집합을 완전히 포함하는 경우  
    이 노드에 미리 계산해 둔 최소치를 곧장 반환하면 됨
- 이 외의 모든 경우  
    두 개의 자손 노드에 대해 query()를 재귀 호출한 뒤, 이 두 값 중 더 작은 값을 택해 반환

```
const int INT_MAX = numeric_limits<int>::max();
struct RMQ{
    // ..생략..
    // node가 표현하는 범위 array[nodeLeft..nodeRight]가 주어질 때
    // 이 범위와 array[left..right]의 교집합의 최소치를 구함
    int query(int left, int right, int node, int nodeLeft, int nodeRight){
        // 두 구간이 겹치지 않으면 아주 큰 값을 반환 : 무시됨
        if(right < nodeLeft || nodeRight < left)    return INT_MAX;
        // node가 표현하는 범위가 array[left..right]에 완전히 포함되는 경우
        if(left <= nodeLeft && nodeRight <= right)  return rangeMin[node];
        // 양쪽 구간을 나눠서 푼 뒤 결과를 합침
        int mid = (nodeLeft + nodeRight) / 2;
        return min(query(left, right, node*2, nodeLeft, mid), 
                   query(left, right, node*2+1, mid+1, nodeRight));
    }
    // query()를 외부에서 호출하기 위한 인터페이스
    int query(int left, int right){
        return query(left, right, 1, 0, n-1);
    }
}
```


---
## 8. 그래프
---

---
> 본 내용은 인사이트에서 출판한 '프로그래밍 대회에서 배우는 알고리즘 문제해결전략' 을 읽고 공부하며 작성하였습니다.
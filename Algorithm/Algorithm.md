# 알고리즘

코딩 테스트 통과 및 컴퓨팅 사고능력을 기르기 위해 학습

---

## 목차
1. [개요](#1.-개요))
2. 문제 해결 시작하기
3. 알고리즘 분석
    - 시간 복잡도 분석
    - 정당성 증명
4. 알고리즘 설계 패러다임
    - 무식하게 풀기
    - 분할 정복
    - 동적 계획법
    - 탐욕법
5. 유명한 알고리즘들
    - 정수론
6. 기초 자료 구조
    - 비트마스트
    - 부분 합
    - 선형 자료 구조
    - 큐, 스택, 데크
7. [트리](#7.-트리)
    - 트리의 구현과 순회
    - 이진 검색 트리
    - 우선순위 큐와 힙
    - 구간 트리
    - 산호 배타적 집합
8. [그래프](#8.-그래프)
    - 그래프의 표현과 정의
    - DFS
    - BFS
    - 최단 경로 알고리즘
    - 최소 스패닝 틜
    - 네트워크 유량

---

---
## 1. 개요
---
### 알고리즘을 잘하기 위한 3요소
1. 구현력
    내가 생각한 알고리즘을 그대로 소스코드로 구현하는 과정  
    구현력 부족 시 대충 어떻게 하라는지는 알지만 코딩은 막힘  
    → 내가 어떤 프로그램을 만들고자 하는지를 명확히!  
    → 무엇을 입력받아 어디에 저장하고 어떤 과정을 거쳐 중간결과와 최종 결과물은 어떤 것인지 파악    
    순서도 그리는 연습!
2. 문제해결능력  
    문제해결능력 부족시 어떻게 접근해야 할지 모름   
    → 양질의 문제를(30~2시간 이내에 고민 및 해결 가능한 문제)를 풀고 이미 풀어본 문제들을 정리  
3. 배경지식 
    기초적인 수학지식을 의미    
    코딩 문법, 시,공간 복잡도 분석, 자료구조(배열, 트리, 그래프, 힙, BST, 스택, 큐), 기초 알고리즘(DFS, BFS, 정렬, 백트래킹, DP, 분할정복, 최단거리)    
    배경지식을 충분히 공부했음에도 문제 접근이 힘들면 컴퓨팅적 사고력이 부족한 것   

---
## 7. 트리
---
### 1. 트리의 구현과 순회
#### 트리
계층적 구조를 갖는 자료들을 표현하기 위한 자료 구조  
현실 세계의 개념을 추상화해 표현하는 자료 구조로 고안되었지만, 탐색형 자료 구조로도 유용하게 쓰임(작업 속도가 빠름)  

#### 트리의 표현
```
struct TreeNode {
    string label;   // 저장할 자료(문자열은 예시)
    TreeNode* parent;   // 부모 노드를 가리키는 포인터
    vector<TreeNode*> chilren;  // 자손 노드들을 가리키는 포인터의 배열
}
```
이 객체 *TreeNode*는 특정 구조나 형태를 가정하지 않음  
즉, 어떤 형태의 트리라도 트리의 가장 기초적인 조건을 충족하기만 한다면 표현할 수 있다는 뜻

#### 트리의 순회
트리는 구조가 일정하지 않기 때문에 포함된 모든 자료들을 순회하기가 어려움  
이와 같은 일을 쉽게 하기 위해서는 **트리의 재귀적 속성**을 이용해야함  
모든 트리는 각 자식들을 루트로 하는 서브트리와 루트로 나눌 수 있으므로, 트리의 루트가 주어질 때 루트를 방문한 뒤 각 서브트리를 재귀적으로 방문하는 함수를 만들어 트리의 모든 노드를 순회할 수 있음
```
// 주어진 트리의 각 노드에 저장된 값을 모두 출력
void printLabels(TreeNode* root){
    // 루트에 저장된 값을 출력
    cout << root->label << endl;
    // 각 자손들을 루트로 하는 서브트리에 포함된 값들을 재귀적으로 호출
    for(int i = 0; i < root->children.size(); i++)
        printLables(root->children[i]);
}
```

트리의 순회에는 O(n)의 시간이 들음

### 2. 이진 검색 트리
**검색 트리**는 연결 리스트나 큐처럼 자료들을 담는 컨테이너지만, 자료들을 일정한 순서에 따라 **정렬한 상태**로 저장해 둠  

이진 검색 트리에서는 각 노드의 왼쪽 서브트리에는 해당 노드의 원소보다 작은 원소를 가진 노드들이, 오른쪽에는 큰 원소를 가진 노드들이 들어감  
이진 검색 트리를 중위 순회하면 크기 순서로 정렬된 원소의 목록을 얻을 수 있음  
이진 검색 트리는 집합에 원소를 추가하거나 삭제하는 **조작 연산**을 할 때 강력함

#### 트립
> 구현이 간단한 균형잡힌 이진 검색 트리  

입력이 특정 순서로 주어질 때 성능이 떨어진다는 이진 검색 트리의 단점을 해결하기 위해 고안된 일종의 **랜덤화된 이진 검색 트리**  
트립은 이진 검색 트리와 같은 성질을 가지고 있지만 트리의 형태가 원소들의 추가 순서에 따라 결정되지 않고 난수에 의해 임의대로 결정됨  
때문에 원소들이 어느 순서대로 추가되고 삭제되더라도 **트리 높이의 기대치**는 **항상 일정**  
이와 같은 속성을 유지하기 위해 트립은 새 노드가 추가될 때마다 해당 노드에 우선순위를 부여 *(이 우선순위는 난수를 통해 생성)*  
트립은 항상 부모의 우선 순위가 자식의 우선순위보다 높은 이진 검색 트리를 만듬 *(힙과도 같은 성질, 힙(heap)과 트리(tree)의 성질을 모두 가지고 있어서 트립(treap))*  
그렇기 때문에 트립의 조건은 다음 두 가지로 정리 가능
 - 이전 검색 트리의 조건 : 모든 노드에 대해 왼쪽 서브트리에 있는 노드들의 원소는 해당 노드의 원소보다 작고, 오른쪽 서브트리에 있는 노드들의 원소는 해당 노드의 원소보다 큼
 - 힙의 조건 : 모든 노드의 우선순위는 각자의 자식 노드보다 크거나 같음

```
typedef int KeyType;
// 트립의 한 노드를 저장
struct Node{
    // 노드에 저장된 원소
    KeyType Key;
    // priority : 이 노드의 우선순위
    // size : 이 노드를 루트로 하는 서브트리의 크기
    int priority, size;
    // 두 자식 노드의 포인터
    Node *left, *right;
    // 생성자에서 난수 우선순위를 생성하고, size와 left / right를 초기화
    Node(const KeyType& _Key) : key(_key), priority(rand()), size(1), left(NULL), right(NULL) {}
    void SetLeft(Node* newLeft) { left = newLeft; calcSize(); }
    void SetRight(Node* newRight) { right = newRight; calcSize(); }
    // size 멤버를 갱신
    void calcSize(){
        size = 1;
        if(left) size += left->size;
        if(right) size += right->size;
    }
}
```

k번째 원소 찾기
이진 검색 트리를 직접 작성하는 것은 표준 라이브러리의 구현에서 제공하지 않는 기능이 필요할 때  
그 중 하나가 주어진 서브트리의 노드들을 포함한 원소의 크기 순으로 나열했을 때 k번째로 오는 노드를 찾는 연산  
Node 클래스는 서브트리의 크기 size를 계산해 저장해 두기 때문에 이것을 구현하기 어렵지 않음
 - k <= l : k번째 노드는 왼쪽 서브트리에 속해 있음
 - k = l+1 : 루트가 k번재 노드
 - k > l+1 : k번째 노드는 오른쪽 서브트리에서 k - l - 1번째 노드가 됨

 ```
 // root를 루트로 하는 트리 중에서 k번째 원소를 반환
 Node* kth(Node* root, int k){
     // 왼쪽 서브트리의 크기를 우선 계산
     int leftSize = 0;
     if(root->left != NULL) leftSize = root->left->size;
     if(k <= leftSize) return kth(root->left, k);
     if(k == leftSize + 1) return root;
     return kth(root->right, k - leftSize - 1);
 }
 ```

### 3. 우선순위 큐와 힙
#### 우선순위 큐
큐와 유사하나 가장 먼저 입력된 자료가 가장 먼저 꺼내지는 것이 아닌,   
**우선순위**가 가장 높은 자료가 가장 먼저 꺼내지는 큐  
균현 잡힌 이진 검색 트리를 사용하면 원소를 찾아 삭제하는 일과 새 원소를 삽입하는 일을 모두 O(logN) 시간에 할 수 있으나, 이는 단순한 작업에 어울리지 않음  
따라서 더욱 단순한 구조로 우선순위 큐를 구현할 필요가 있음

#### 힙
이에 적합한 것이 **힙(heap)**  
힙은 가장 큰 원소를 찾는 것에 최적화된 형태의 이진 트리  
새 원소를 추가하는 연산과 가장 큰 원소를 꺼내는 연산을 모두 O(logN) 시간에 수행 가능  
대부분의 프로그래밍 언어의 표준 라이브러리에 포함되어 있기 때문에 직접 구현할 일이 거의 없음

힙이 갖는 가장 중요한 규칙은 부모 노드가 가진 원소는 항상 자식 노드가 가진 원소 이상이라는 것, 이를 **힙의 대소 관계 규칙**이라고 부름  
힙에서 대소 관계 규칙은 부모 자식 관계에만 적용되며, 왼쪽 자식과 오른쪽 자식이 갖는 원소의 크기는 제한하지 않음  

트리가 한쪽으로 기울어지는 일을 막기 위해서 힙 또한 트리의 구조에 제한을 둠
 - 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차있어야 함
 - 마지막 레벨에 노드가 있을 때는 항상 가장 왼쪽부터 순서대로 채워져 있어야 함  

이러한 엄격한 모양 규칙은 구현할 때 장점으로 작용함  
 - A[i]에 대응되는 노드의 왼쪽 자손은 A[2 x i + 1]에 대응됨
 - A[i]에 대응되는 노드의 오른쪽 자손은 A[2 x i + 2]에 대응됨
 - A[i]에 대응되는 노드의 부모는 A[(i - 1) / 2]에 대응됨(나눗셈 결과는 내림)
 
힙의 모양 규칙에 의해 힙에 n개의 노드가 있을 때 이 노드들은 A[0]에서 A[n-1]까지 순차적으로 대응함

#### 새 원소의 삽입
힙의 모든 조건을 유지하면서 새 원소를 삽입 할 때 여러 번거로움을 피할 수 있는 방법은 대소 관계 규칙 대신 모양 규칙을 먼저 만족시키는 것  
모양 규칙에 의해 새 노드는 항상 heap[]의 맨 끝에 추가한 후 힙의 대소 관계 속성을 만족시키기는 간단함  
마지막에 추가한 새 원소를 자신의 부모 노드가 가진 원소와 비교하고, 부모 노드가 가진 원소가 작다면 두 원소의 위치를 바꿈. 새 원소가 더 크거나 같은 원소를 가진 부모 노드를 만나거나 루트에 도달할 때까지 반복
```
// 정수를 담는 최대 힙 heap에 새 원소 newValue를 삽입 
void push_heap(vector<int>& heap, int newValue){
    // 힙의 맨 끝에 newValue를 추가
    heap.push_back(newValue)
    // 현재 newValue의 위치
    int idx = heap.size() - 1;
    // 루트에 도달하거나 newValue 이상의 원소를 가진 조상을 만날 때까지
    while(idx > 0 && heap[(idx - 1) / 2] < heap[idx]){
        swap(heap[idx], heap[(idx - 1) / 2]);
        idx = (idx - 1) / 2;
    }
}
```

#### 최대 원소 꺼내기


---
## 8. 그래프
---

---
> 본 내용은 인사이트에서 출판한 '프로그래밍 대회에서 배우는 알고리즘 문제해결전략' 을 읽고 공부하며 작성하였습니다.
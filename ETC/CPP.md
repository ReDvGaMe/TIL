# CPP 전체적인 개념 정리

---

## OOP(Object-Oriented Programing)
컴퓨터 프로그래밍의 패러다임  
프로그램을 명령어의 목록이 아닌, 독립된 "객체"들의 모임으로 바라봄

객체란, 변수들과 참고 자료들로 이루어진 소프트웨어 덩어리  

특징  
- **추상화 (abstraction)**
    - 대상의 특성 중 불필요한 부분을 무시하고 필요한 공통점만을 다루어, 현실의 복잡성을 극복하고 목적에 집중할 수 있도록 하는 것

    - 공통의 속성이나 기능을 묶어 이름을 붙이는 것

    - Class를 정의하는 것

- **캡슐화 (Encapsulation)**  
    - 객체 스스로가 자신의 상태를 책임지게 하여, 해당 객체의 역할 수행에 집중할 수 있도록 자율성을 높이는 것

    - 데이터 구조와 데이터를 다루는 방법들을 결합시켜 묶는 것

    - 변수와 함수를 하나로 묶는 것

    - 데이터를 외부에서 접근하는 것을 방지하고, 오로지 함수를 통해서만 접근할 수 있게 하는 것

    - 캡슐화의 2가지 관점

        1) 상태-행위 캡슐화 (데이터 캡슐화) : 객체는 상태와 행동을 하나의 단위로 묶는 자율적 실체

        2) 사적인 비밀의 캡슐화 (은닉화) : 외부에서 객체의 상태를 변경할 수 없도록 은닉

    - 접근 변경자

        public > protected > default > private

        모든 접근 허용 > default + 상속 관계인 다른 패키지의 클래스 > 같은 패키지 > 같은 클래스  

- **상속성 (Ingeritance)**  

    - 부모 클래스의 속성과 기능을 상속받아 동일하게 사용하는 것

    - 범용적인 클래스를 작성한 후 상속을 활용하면, 여러 클래스에서 중복되는 속성과 기능을 재사용할 수 있음

- **다형성 (Polymorphism)**

    - 동일 요청에 대해 서로 다른 방식으로 응답할 수 있도록 만드는 것

    - 오버라이딩 (Overriding) : 상속받은 동일한 메소드 재정의

    - 오버로딩 (Overloading) : 동일한 메소드가 매개변수 타입, 개수 차이에 따라 다르게 동작 

C++ 에서 클래스를 이용해서 만들어진 객체를 **인스턴스(instance)** 라고 부름  

---

## 복사 생성자 (copy constructor)
```
T(const T& a);
```
다른 T 의 객체 a 를 상수 레퍼런스로 받음  
여기서 a 가 const 이기 때문에 우리는 복사 생성자 내부에서 a 의 데이터를 변경할 수 없고,  
오직 새롭게 초기화 되는 인스턴스 변수들에게 '복사' 만 할 수 있게 됨  

```
Photon_Cannon::Photon_Cannon(const Photon_Cannon& pc) {
  std::cout << "복사 생성자 호출 !" << std::endl;
  hp = pc.hp;
  shield = pc.shield;
  coord_x = pc.coord_x;
  coord_y = pc.coord_y;
  damage = pc.damage;
}
```
위와 같이 복사 생성자 내부에서 pc 의 인스턴스 변수들에 접근해서 객체의 shield, coord_x, coord_y 등을 초기화 할 수 는 있지만

`pc.coord_x = 3;` 처럼 pc 의 값 자체는 변경할 수 없다는 이야기

`Photon_Cannon pc2 = pc1;`  
위 코드 역시 복사 생성자가 호출  
C++ 컴파일러는 위 문장을 아래와 동일하게 해석  
`Photon_Cannon pc2(pc1);`  

C++ 컴파일러는 디폴트 복사 생성자를 지원, 이는 대응되는 원소들을 1 대 1 복사를 해줌

### 디폴트 복사 생성자의 한계
만약 초기화되는 멤버 변수 중 포인터가 있을때 디폴트 복사 생성자를 사용하면  
기존의 클래스에 있는 포인터와 새로 생성된 클래스에 있는 포인터가 같은 값을 가지게 됨  

이 때, 하나의 클래스가 소멸하며 포인터에 할당되어있던 메모리를 해제하면 남은 클래스에서는 해제된 메모리 주소를 가리키고 있음  
이런 상태에서 남은 클래스의 포인터를 해제시키려하면 이미 해제된 메모리에 접근하기때문에 런타임 오류가 발생  

이를 막기 위해서는 해당 포인터를 그대로 복사하지 말고 따로 다른 메모리에 동적 할당을 해서 그 내용만 복사하면 됨  

이렇게 메모리를 새로 할당해서 내용을 복사하는 것을 **깊은 복사(deep copy)**,  
단순히 대입만 해주는 것을 **얕은 복사(shallow copy)** 라고 함

컴파일러가 생성하는 디폴트 복사 생성자의 경우 얕은 복사밖에 할 수 없으므로 깊은 복사가 필요한 경우에는 사용자가 직접 복사 생성자를 만들어야함  

